/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
desc:Humonica - Harmoniser/Harmonizer (by Geraint Luff)

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:attack_ms=5<0,1000,1>-Attack (ms)
slider2:release_ms=10<1,2000,1>-Release (ms)
slider3:window_ms=30<20,150,1>-Window (ms)
slider4:crossover_ratio=1.25<1,10,0.25>-Window crossover factor
slider5:latency_switch=1<0,1,1{live,compensated}>-Latency compensation
slider6:stereo_switch=0<0,1,1{2ch,1ch}>-Stereo
slider7:timbre_shift_semitones=0<-12,12,0.1>-Timbre shift (semitones)
slider8:timbre_shift_tracking=0<-1,1,0.01>-Timbre key-tracking (relative to middle C)
slider9:lowpass_freq_khz=8<1,20,0.1>-Lowpass (kHz)
slider10:vibrato_tracking=0<0,1,0.01>-Vibrato tracking
slider11:tonality_limit=0<0,0.5,0.01>-Tonality limit
slider12:lr_detune_cents=3<0,100,1>-L/R detune
slider13:vib_mode=1<0,1,1{tracking,LFO}>-Vib mode
slider14:vib_lfo_scale_cents=5<0,100,1>-Vib LFO cents
slider15:vib_lfo_hz=4<0.5,10,.01>-Vib LFO Hz
slider16:vib_lfo_attack_ms=350<1,2000,1>-Vib LFO attack (ms)
slider17:stereo_width=0.5<0,1,0>-Stereo Width

import ui-lib.jsfx-inc
import synth-framework.jsfx-inc
import filter-utils.jsfx-inc

@init
gfx_ext_retina = 1;

// TODO: why do we need this?
// On init (playback), the UI flashes an "unknown screen" error briefly
// The @gfx code runs in a different thread, so this could be a race condition interacting with the shuffling of ui_setup() around.
// We already had to introduce a minimum for srate because otherwise certain important lengths == 0, which caused infinite loops.
!srate ? srate = max(last_srate, 8000);
last_srate = srate;

debug.init_count += 1;
debug.init_srate3 = debug.init_srate2;
debug.init_srate2 = debug.init_srate;
debug.init_srate = srate;

FFT_MAX_SIZE = 32768;
MAX_WINDOW_MS = 200;
MAX_WINDOW_SAMPLES = srate*MAX_WINDOW_MS*0.001;

freemem = 0;
freemem = (fft_block = freemem) + FFT_MAX_SIZE*2;
kernel_length = MAX_WINDOW_SAMPLES;
freemem = (kernelA0 = freemem) + kernel_length;
freemem = (kernelA0_dc = freemem) + kernel_length;
freemem = (kernelA1_read = kernelA1 = freemem) + kernel_length;
freemem = (kernelA1_read_dc = kernelA1_dc = freemem) + kernel_length;
freemem = (kernelB0 = freemem) + kernel_length;
freemem = (kernelB0_dc = freemem) + kernel_length;
freemem = (kernelB1_read = kernelB1 = freemem) + kernel_length;
freemem = (kernelB1_read_dc = kernelB1_dc = freemem) + kernel_length;
input_buffer_length = MAX_WINDOW_SAMPLES + 10;
freemem = (input_buffer0 = freemem) + input_buffer_length;
freemem = (input_buffer1 = freemem) + input_buffer_length;

// Wipe all buffers
i = 0;
while (i < freemem) (
	i[] = 0;
	i += 1;
);

freemem = ui_setup(freemem);
freemem = synth_setup(freemem, 9/*NOTE: TIMBRE_FACTOR, WAVELENGTH_L, INDEX_L, LFO_PHASE_L, LFO_FREQ_DIFF_L, WAVELENGTH_R, INDEX_R, LFO_PHASE_R, LFO_FREQ_DIFF_R*/);

freemem = filter_buffer_init(filter_left = freemem);
freemem = filter_buffer_init(filter_right = freemem);

freemem = filter_buffer_init(freq_factor_filter = freemem);
filter_buffer_highpass(freq_factor_filter, 3, 1.5);

@slider

function check_for_old_presets() (
	// Catch presets from before v2
	// We deliberately changed how the crossover slider is stored so that we could do this
	crossover_ratio >= 40 ? (
		// Older versions stored a "crossover_percent" value, so we convert
		crossover_ratio = 50/(100 - crossover_ratio);

		// Emulate pre-v2 behaviour
		lr_detune_cents = 0; // Detuning didn't exist
		stereo_width = 1; // Didn't have stereo width control
		vibrato_tracking || tonality_limit ? (
			vib_mode = 0; // tracking mode used to be the only option
		) : (
			vib_lfo_scale_cents = 0; // stay in LFO mode, but have no amplitude
		);
	);
);

check_for_old_presets();

@block

crossover_percent = 100 - 50/crossover_ratio;

attack_samples = srate*attack_ms*0.001;
release_samples = srate*release_ms*0.001;
window_samples = max(srate, 8000)*window_ms*0.001;
interval_samples = window_samples*(1 - crossover_percent/100);
fft_size = pow(2, ceil(log(window_samples*1.5)/log(2)));
abs(timbre_shift_semitones) > 0.1 ? (
	timbre_shift_factor = pow(2, timbre_shift_semitones/12);
) : (
	timbre_shift_factor = 1;
);

input_buffer0[input_index] = 0;
input_buffer1[input_index] = 0;

any_notes_active = synth_block();

latency_samples = latency_switch ? window_samples*0.5 + interval_samples : 0;

pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = latency_samples;

note = synth_note_first();
while (note > 0) (
	note[0/*NOTE:TIMBRE_FACTOR*/] = pow(2, timbre_shift_tracking*(synth_midinote(note) - 60)/12);
	note = synth_note_next(note);
);

lowpass_freq = lowpass_freq_khz*1000;
filter_buffer_lowpass(filter_left, lowpass_freq, 1.4);
filter_buffer_lowpass(filter_right, lowpass_freq, 1.4);

freq_slew = 1/(interval_samples + 0.03*srate);
!freq_factor ? freq_factor = 1;

tonality_smooth_seconds = 0.05;
tonality_smooth_slew = 1/(tonality_smooth_seconds*srate);

wavelength_average_seconds = 0.3;
wavelength_average_slew = 1/(wavelength_average_seconds*srate);
//wavelength_average = target_wavelength = 0;

lr_detune_factor = pow(2, lr_detune_cents/1200/2);
vib_lfo_scale_factor = pow(2, vib_lfo_scale_cents/1200) - 1;
vib_lfo_attack_samples = srate*vib_lfo_attack_ms/1000;
vib_lfo_wavelength_samples = srate/vib_lfo_hz;

half_kernel_length = kernel_length >> 1;
half_kernel_length_minus_one = half_kernel_length - 1;

@sample

function smooth_fade(phase) (
	phase*phase*(3 - 2*phase);
);

input_buffer0[input_index] = spl0;
input_buffer1[input_index] = spl1;
input_index += 1;
input_index >= input_buffer_length ? (
	input_index = 0;
);

function fill_kernel(kernel, kernel_dc, buffer, secondary_buffer) local(peak, norm_factor, sum1, sum2, max_abs, i, i2, ratio, window_value, index, real, imag, mag) (
	i = 0;
	max_abs = 0;
	// Fill with input
	while (i < window_samples && i < fft_size) (
		ratio = i/window_samples;
		window_value = 0.5 - 0.5*cos(ratio*2*$pi);
		index = input_index - i;
		while (index < 0) (
			index += input_buffer_length;
		);
		fft_block[i*2] = buffer[index]*window_value;
		max_abs = max(max_abs, abs(buffer[index]));
		secondary_buffer >= 0 ? (
			fft_block[i*2 + 1] = secondary_buffer[index]*window_value;
			max_abs = max(max_abs, abs(secondary_buffer[index]));
		) : (
			fft_block[i*2 + 1] = 0;
		);
		i += 1;
	);
	max_abs > 0.00000001 ? (
		while (i < fft_size) (
			fft_block[i*2] = 0;
			fft_block[i*2 + 1] = 0;
			i += 1;
		);

		// Zero-phase
		fft(fft_block, fft_size);
		fft_block[0] = fft_block[1] = 0;
		i = 1;

		while (i < fft_size) (
			real = fft_block[i*2];
			imag = fft_block[i*2 + 1];
			mag2 = real*real + imag*imag;
			mag = sqrt(mag2);

			fft_block[i*2] = mag/fft_size;
			fft_block[i*2 + 1] = 0;
			i += 1;
		);
		ifft(fft_block, fft_size);

		// Zero out kernel
		memset(kernel, 0, kernel_length);

		// Place result in kernel
		i = 0;
		window_value = (secondary_buffer >= 0) ? sqrt(0.5) : 1;
		while (i < fft_size*0.5 && i < half_kernel_length) (
			i2 = i ? (kernel_length - i) : 0;
			kernel[i] = fft_block[i*2]*window_value;
			kernel[i2] = kernel[i];
			i += 1;
		);

		// Sum
		i = 0;
		sum1 = 0;
		while (i < half_kernel_length) (
			sum1 += kernel[i];
			kernel_dc[i] = sum1;
			i += 1;
		);

		i = 0;
		sum1 = 0;
		while (i < half_kernel_length) (
			sum1 += kernel_dc[i];
			sum2 = (i + 1)*(i + 2)*0.5;
			kernel_dc[i] = sum1/sum2;
			i += 1;
		);
	) : (
		// Zero out kernel
		memset(kernel, 0, kernel_length);
	);
);

interval_index += 1;
any_notes_active ? (
	interval_index >= interval_samples ? (
		interval_index = 0;

		// Swap kernels
		tmp = kernelA0;
		kernelA0 = kernelB0;
		kernelB0 = tmp;
		tmp = kernelA1;
		kernelA1 = kernelB1;
		kernelB1 = tmp;
		tmp = kernelA1_read;
		kernelA1_read = kernelB1_read;
		kernelB1_read = tmp;
		tmp = kernelA0_dc;
		kernelA0_dc = kernelB0_dc;
		kernelB0_dc = tmp;
		tmp = kernelA1_dc;
		kernelA1_dc = kernelB1_dc;
		kernelB1_dc = tmp;
		tmp = kernelA1_read_dc;
		kernelA1_read_dc = kernelB1_read_dc;
		kernelB1_read_dc = tmp;

		stereo_switch ? (
			fill_kernel(kernelB0, kernelB0_dc, input_buffer0, -1);
			fill_kernel(kernelB1, kernelB1_dc, input_buffer1, -1);
			kernelB1_read = kernelB1;
			kernelB1_read_dc = kernelB1_dc;
		) : (
			fill_kernel(kernelB0, kernelB0_dc, input_buffer0, input_buffer1);
			// TODO: have "true" slot, and instead of copying, point kernel?1 to kernel?0.
			kernelB1_read = kernelB0;
			kernelB1_read_dc = kernelB0_dc;
			//memcpy(kernelB1, kernelB0, kernel_length);
			//memcpy(kernelB1_dc, kernelB0_dc, half_kernel_length);
		);

		vib_mode == 0 && (vibrato_tracking || tonality_limit) ? (
			lowest_value = 0;
			highest_value = 0;
			highest_index = 0;
			i = 0;
			while (i < kernel_length/2) (
				value = (kernelB0[i] + kernelB1_read[i]);
				value < lowest_value ? (
					highest_value = highest_index = 0;
					lowest_value = value;
				) : value > highest_value ? (
					highest_value = value;
					highest_index = i;
				);
				i += 1;
			);
			highest_index ? (
				target_wavelength = highest_index;
			);

			tonality_limit ? (
				first_value = (kernelB0[0] + kernelB1_read[0]);
				tonality = first_value ? highest_value/first_value : 0;
				factor = max(0, min(1, (tonality - tonality_limit)/tonality_limit));
				tonality_factor += (factor - tonality_factor)*tonality_smooth_slew*interval_samples;

				i = 0;
				while (i < kernel_length) (
					kernelB0[i] *= tonality_factor;
					kernelB1_read[i] *= tonality_factor;
					i += 1;
				);
			);
		);
	);
	kernel_crossfade = smooth_fade(interval_index/interval_samples);
);

vibrato_tracking ? (
	low_factor = 0.98;
	high_factor = 1/low_factor;
	wavelength_average += (target_wavelength - wavelength_average)*wavelength_average_slew;
	wavelength_average = max(target_wavelength*low_factor, min(target_wavelength*high_factor, wavelength_average));
	target_ratio = target_wavelength/wavelength_average;
	//target_ratio = max(low_factor, min(high_factor, target_ratio));
	target_ratio = 1 + filter_buffer_sample(freq_factor_filter, target_ratio - 1);
	target_ratio = max(low_factor, min(high_factor, target_ratio));

	freq_factor += (target_ratio - freq_factor)*freq_slew;
) : (
	freq_factor = 1;
);

spl0 = spl1 = 0;

synth_sample();

function interp_sample(index, wavelength, kernelA, kernelB, dcA, dcB) local(result, phase, indexA, indexB, floor_indexA, floor_indexB, floor_indexA2, floor_indexB2, ratioA, ratioB, valueA, valueB) (
	phase = smooth_fade(index/wavelength);

	indexA = min(index*timbre_factor, half_kernel_length_minus_one);
	indexB = max(half_kernel_length, kernel_length + (index - wavelength)*timbre_factor);
	floor_indexA = floor(indexA);
	floor_indexB = floor(indexB);
	floor_indexA2 = floor_indexA + 1;
	floor_indexB2 = floor_indexB + 1;
	floor_indexB2 >= kernel_length ? floor_indexB2 = 0;
	ratioA = indexA - floor_indexA;
	ratioB = indexB - floor_indexB;

	valueA = kernelA[floor_indexA];
	valueA += (kernelA[floor_indexA2] - valueA)*ratioA;
	valueB = kernelA[floor_indexB];
	valueB += (kernelA[floor_indexB2] - valueB)*ratioB;
	result = valueA + (valueB - valueA)*phase - dcA;

	valueA = kernelB[floor_indexA];
	valueA += (kernelB[floor_indexA2] - valueA)*ratioA;
	valueB = kernelB[floor_indexB];
	valueB += (kernelB[floor_indexB2] - valueB)*ratioB;
	value = valueA + (valueB - valueA)*phase - dcB;
	result + (value - result)*kernel_crossfade;
);

note = synth_note_first();
while (note > 0) (
	synth_needs_init(note) ? (
		note[1/*NOTE:WAVELENGTH_L*/] = srate/synth_freq(note);
		note[2/*NOTE:INDEX_L*/] = floor(rand()*note[1/*NOTE:WAVELENGTH_L*/]);
		note[3/*NOTE:LFO_PHASE_L*/] = rand();
		note[4/*NOTE:LFO_FREQ_DIFF_L*/] = lr_detune_cents > 0 ? 0.9 + 0.2*rand() : 1;
		note[5/*NOTE:WAVELENGTH_R*/] = srate/synth_freq(note);
		note[6/*NOTE:INDEX_R*/] = lr_detune_cents > 0 ? floor(rand()*note[5/*NOTE:WAVELENGTH_R*/]) : note[2/*NOTE:INDEX_L*/];
		note[7/*NOTE:LFO_PHASE_R*/] = lr_detune_cents > 0 ? rand() : note[3/*NOTE:LFO_PHASE_L*/];
		note[8/*NOTE:LFO_FREQ_DIFF_R*/] = lr_detune_cents > 0 ? 0.9 + 0.2*rand() : 1;
		note[0/*NOTE:TIMBRE_FACTOR*/] = pow(2, timbre_shift_tracking*(synth_midinote(note) - 60)/12);
	);

	amp = synth_velocity(note)/127;
	attack = synth_attack(note) - latency_samples;
	attack >= 0 ? (
		attack < attack_samples ? (
			amp *= attack/attack_samples;
		);
		release = synth_sustain_release(note) - latency_samples;
		release > 0 ? (
			release >= release_samples ? (
				synth_stop(note);
				amp = 0;
			) : (
				amp *= (1 - release/release_samples);
			);
		);

		index_l = (note[2/*NOTE:INDEX_L*/] += 1);
		wavelength_l = note[1/*NOTE:WAVELENGTH_L*/];
		index_l >= wavelength_l ? (
			while (index_l >= wavelength_l) (
				index_l -= wavelength_l;
			);
			vibrato_factor = vib_mode ? (
				phase = (attack/vib_lfo_wavelength_samples + note[3/*NOTE:LFO_PHASE_L*/])*note[4/*NOTE:LFO_FREQ_DIFF_L*/];
				1 + sin(phase*2*$pi)*vib_lfo_scale_factor*min(1, attack/vib_lfo_attack_samples);
			) : (
				vibrato_tracking ?
					pow(freq_factor, min(1, attack/(0.3*srate))*vibrato_tracking)
				: 1;
			);
			wavelength_l = note[1/*NOTE:WAVELENGTH_L*/] = srate/synth_freq(note)*vibrato_factor*lr_detune_factor;
			while (index_l >= wavelength_l) (
				index_l -= wavelength_l;
			);
			note[2/*NOTE:INDEX_L*/] = index_l;
		);
		index_r = (note[6/*NOTE:INDEX_R*/] += 1);
		wavelength_r = note[5/*NOTE:WAVELENGTH_R*/];
		index_r >= wavelength_r ? (
			while (index_r >= wavelength_r) (
				index_r -= wavelength_r;
			);
			vibrato_factor = vib_mode ? (
				phase = (attack/vib_lfo_wavelength_samples + note[7/*NOTE:LFO_PHASE_R*/])*note[8/*NOTE:LFO_FREQ_DIFF_R*/];
				1 + sin(phase*2*$pi)*vib_lfo_scale_factor*min(1, attack/vib_lfo_attack_samples);
			) : (
				vibrato_tracking ?
					pow(freq_factor, min(1, attack/(0.3*srate))*vibrato_tracking)
				: 1;
			);
			wavelength_r = note[5/*NOTE:WAVELENGTH_R*/] = srate/synth_freq(note)*vibrato_factor/lr_detune_factor;

			while (index_r >= wavelength_r) (
				index_r -= wavelength_r;
			);
			note[6/*NOTE:INDEX_R*/] = index_r;
		);

		timbre_factor = timbre_shift_factor*note[0/*NOTE:TIMBRE_FACTOR*/];

		// Left
		wavelength_floor = floor(note[5/*NOTE:WAVELENGTH_R*/]*timbre_factor);
		left = interp_sample(index_l, wavelength_l, kernelA0, kernelB0, kernelA0_dc[wavelength_floor], kernelB0_dc[wavelength_floor]);
		right = interp_sample(index_r, wavelength_r, kernelA1_read, kernelB1_read, kernelA1_read_dc[wavelength_floor], kernelB1_read_dc[wavelength_floor]);

		spl0 += left*amp;
		spl1 += right*amp;
	);

	note = synth_note_next(note);
);

spl0 = filter_buffer_sample(filter_left, spl0);
spl1 = filter_buffer_sample(filter_right, spl1);

splm = (spl0 + spl1)*0.5;
spls = (spl0 - spl1)*0.5*stereo_width;

spl0 = splm + spls;
spl1 = splm - spls;

@gfx 645 400

function labelled_dial(value, low, high, bias, label, number_format, default) (
	ui_push_height(50);
		value = control_dial(value, low, high, bias, default);
	ui_pop();
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		number_format >= 0 ? (
			ui_textnumber(value, number_format);
		);
	ui_pop();
	value;
);

function labelled_switch(value, label, text) (
	ui_push_height(30);
		ui_push_width(60);
			value = control_switch(value);
		ui_pop();
	ui_pop();
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		ui_text(text);
	ui_pop();
	value;
);
control_start("main", "default");

ui_screen() == "main" ? (
	control_navbar("Humonica", "help", "help");

	ui_split_bottomratio(0.15);
		control_background_technical();
		ui_graph_circular(kernelA0[0] ? kernelA0 : kernelA1, window_samples, 1, -window_samples/2, kernel_length, p0.00000001, 0.00000001);
		control_finish_technical();
	ui_pop();

	ui_split_topratio(0.5);
		ui_split_leftratio(4/7);
			control_group("Analysis");
			ui_pad(-1, 0);
			ui_split_leftratio(1/4);
				window_ms = labelled_dial(window_ms, 5, 150, 1.5, "Window", "%ims", 30);
			ui_split_next();
				crossover_ratio = labelled_dial(crossover_ratio, 1, 10, 3, "Overlap", "x%.2f", 1.25);
			ui_split_next();
				latency_switch = labelled_switch(latency_switch, "Latency", latency_switch ? "compensated" : "zero (live)");
			ui_split_next();
				stereo_switch = labelled_switch(stereo_switch, "Stereo", stereo_switch ? "separate" : "joined");
			ui_pop();
		ui_pop();

		ui_split_leftratio(3/3);
			control_group("Timbre");
			ui_pad(-1, 0);
			ui_split_leftratio(1/3);
				timbre_shift_semitones = labelled_dial(timbre_shift_semitones, -12, 12, 0, "Shift", "%.1f st", 0);
			ui_split_next();
				timbre_shift_tracking = labelled_dial(timbre_shift_tracking, -0.5, 0.5, 0, "Tracking", "(relative to\nmiddle C)", 0);
			ui_split_next();
				lowpass_freq_khz = labelled_dial(lowpass_freq_khz, 1, 20, 2, "Filter", "%.f kHz", 8);
			ui_pop();
		ui_pop();
	ui_pop();

	ui_split_leftratio(2/8);
		control_group("Stereo");
		ui_split_leftratio(1/2);
			lr_detune_cents = labelled_dial(lr_detune_cents, 0, 100, 4, "Detune", lr_detune_cents < 2 ? "%.1f cents" : "%i cents", 3);
		ui_split_next();
			stereo_width = labelled_dial(stereo_width, 0, 1, 0, "Width", "", 0.5);
		ui_pop();
	ui_pop();

	ui_split_leftratio(4/6);
		control_group("Vibrato");
		ui_split_leftratio(1/4);
			vib_mode = labelled_switch(vib_mode, "Vibrato", vib_mode ? "LFO" : "tracking");
		ui_split_next();
			vib_mode ? (
				vib_lfo_scale_cents = labelled_dial(vib_lfo_scale_cents, 0, 100, 4, "Depth", "%i cents", 5);
			) : (
				vibrato_tracking = max(0, labelled_dial(vibrato_tracking, -0.001, 1, 0, "Tracking", "strength", 0));
			);
		ui_split_next();
			vib_mode ? (
				vib_lfo_hz = labelled_dial(vib_lfo_hz, 0.5, 10, 3, "Freq", "%.1f Hz", 4);
			) : (
				tonality_limit = labelled_dial(tonality_limit, 0, 0.5, 0, "Tonality", "limit", 0);
			);
		ui_split_next();
			vib_mode ? (
				vib_lfo_attack_ms = labelled_dial(vib_lfo_attack_ms, 1, 2000, 4, "Attack", "%ims", 350);
			) : (
				0;
			);
		ui_pop();
	ui_pop();

	ui_split_leftratio(2/2);
		control_group("Envelope");
		ui_split_leftratio(1/2);
			attack_ms = labelled_dial(attack_ms, 0, 1000, 5, "Attack", "%ims", 5);
		ui_split_next();
			release_ms = labelled_dial(release_ms, 0, 2000, 5, "Release", "%ims", 10);
		ui_pop();
	ui_pop();

) : ui_screen() == "help" ? (
	control_navbar("Humonica - Help", -1, -1);

	ui_align(0, 0);
	ui_wraptext("Window: controls how much input audio is used to calculate the impulse for resynthesis.  Lower values give a faster-changing sound (better time-resolution), but reduced frequency resolution.\n\nOverlap: controls how often the impulse is recalculated, as a function of the window length.  Higher values mean recalculating more often, which gives a smoother result, at the expense of more calculation.\n\nLatency: the impulse is calculated using input audio. This switch chooses between zero-latency (\"live\") mode, where the analysis will always be slightly behind the input audio (depending on window length and overlap amount) or whether some extra latency is added to compensate.\n\nStereo: the left and right inputs can either be combined (their energy is added together) or calculated separately. 1-channel mode is slightly more efficient, so should be used unless you particularly need separate stereo channels.");
) : ui_system();

@serialize

preset_version = 2;
file_var(0, preset_version);
